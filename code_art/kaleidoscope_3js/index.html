<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kaleidoscope — Three.js + PostFX</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; }
    .dg.main { z-index: 10 !important; }
  </style>
</head>
<body>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">

/* ===== Imports ===== */
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass }     from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { ShaderPass }     from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/ShaderPass.js';
import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

/* ===== Parameter model (same spirit as your p5 version) ===== */
const paramDefs = {
  tileCount:      { min: 1,    max: 50,   step: 1,     default: 10 },
  squareSize:     { min: 0.05, max: 0.5,  step: 0.01,  default: 0.3 },
  thickness:      { min: 0.01, max: 0.5,  step: 0.01,  default: 0.15 },
  kaleidoSides:   { min: 1,    max: 32,   step: 1,     default: 8 },
  speed:          { min: 0.0,  max: 2.0,  step: 0.01,  default: 0.5 },

  distortionAmp:  { min: 0.0,  max: 0.5,  step: 0.01,  default: 0.05 },
  distortionFreq: { min: 0.0,  max: 100,  step: 1,     default: 5.0 },

  chromaOffset:   { min: 0.0,  max: 0.2,  step: 0.001, default: 0.01 },
  chromaBlur:     { min: 0.0,  max: 0.5,  step: 0.01,  default: 0.05 },

  glowStrength:   { min: 0.0,  max: 1.0,  step: 0.01,  default: 0.5 },
  glowSteps:      { min: 1,    max: 20,   step: 1,     default: 5 },

  spiralStrength: { min: 0.0,  max: 1.0,  step: 0.01,  default: 0.5 },
  spiralSpeed:    { min: 0.0,  max: 1.0,  step: 0.01,  default: 0.5 },
  spiralMode:     { min: 0,    max: 1,    step: 1,     default: 0 }, // 0=osc, 1=compound

  // Glitch pass
  strength:       { min: 0.0,  max: 0.2,  step: 0.001, default: 0.005 },
  chunkSize:      { min: 1,    max: 100,  step: 1,     default: 10 },
  glitchSpeed:    { min: 0.0,  max: 10,   step: 0.1,   default: 0.0 },
  chance:         { min: 0.0,  max: 1.0,  step: 0.01,  default: 1.0 },
};
const randomDamping = 0.75;

const params = {};
for (const k in paramDefs) params[k] = paramDefs[k].default;

/* ===== Three.js scene ===== */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// Fullscreen ortho scene
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
const quadGeo = new THREE.PlaneGeometry(2,2);
const quad = new THREE.Mesh(quadGeo, new THREE.MeshBasicMaterial({ color:0x000000 }));
scene.add(quad);

// Composer & passes (RenderPass not required since we generate in shader)
const composer = new EffectComposer(renderer);

// 1) Kaleido (generator) pass — writes base pattern
const KaleidoShader = {
  uniforms: {
    u_time:         { value: 0 },
    u_resolution:   { value: new THREE.Vector2(innerWidth, innerHeight) },
    u_tileCount:    { value: params.tileCount },
    u_squareSize:   { value: params.squareSize },
    u_thickness:    { value: params.thickness },
    u_kaleidoSides: { value: params.kaleidoSides },
    u_speed:        { value: params.speed },
    u_distortionAmp:{ value: params.distortionAmp },
    u_distortionFreq:{ value: params.distortionFreq },
    u_spiralStrength:{ value: params.spiralStrength },
    u_spiralSpeed:  { value: params.spiralSpeed },
    u_spiralMode:   { value: params.spiralMode }, // int-ish 0/1
  },
  vertexShader: /* glsl */`
    varying vec2 vUv;
    void main(){
      vUv = position.xy * 0.5 + 0.5;
      gl_Position = vec4(position, 1.0);
    }
  `,
  fragmentShader: /* glsl */`
    precision mediump float;
    varying vec2 vUv;
    uniform vec2  u_resolution;
    uniform float u_time;
    uniform float u_tileCount, u_squareSize, u_thickness;
    uniform float u_kaleidoSides;
    uniform float u_speed;
    uniform float u_distortionAmp, u_distortionFreq;
    uniform float u_spiralStrength, u_spiralSpeed, u_spiralMode;

    // Helpers
    float square(vec2 uv, float size){
      vec2 d = abs(uv - 0.5);
      return step(max(d.x, d.y), size);
    }

    vec2 kaleido(vec2 uv, float sides){
      uv -= 0.5;
      float ang = atan(uv.y, uv.x);
      float rad = length(uv);
      ang = mod(ang, 6.2831853 / sides);
      ang = abs(ang - 3.14159265 / sides);
      return vec2(cos(ang), sin(ang)) * rad + 0.5;
    }

    vec2 refractDistort(vec2 uv, float time, float offset){
      float f = u_distortionFreq;
      float a = u_distortionAmp;
      uv.x += sin(uv.y * f + time * 2.0 + offset) * a;
      uv.y += cos(uv.x * f - time * 2.0 + offset) * a;
      return uv;
    }

    // Spiral warp with selectable mode
    vec2 spiralWarp(vec2 uv, float time){
      vec2 c = uv - 0.5;
      float r = length(c);
      float normR = r / 0.7071;
      float ang = atan(c.y, c.x);
      float twist = (u_spiralMode > 0.5) ? (time * u_spiralSpeed)
                                         : sin(time * u_spiralSpeed);
      ang += normR * u_spiralStrength * twist;
      return vec2(cos(ang), sin(ang)) * r + 0.5;
    }

    // Single-channel render
    float renderPattern(vec2 uv, float offset) {
      float t = u_time * u_speed;
      // aspect fix
      uv -= 0.5;
      uv.x *= u_resolution.x / u_resolution.y;
      uv += 0.5;

      uv = spiralWarp(uv, t);
      uv = kaleido(uv, u_kaleidoSides);
      uv = refractDistort(uv, t, offset);
      uv = fract(uv * u_tileCount);

      float outer = square(uv, u_squareSize);
      float inner = square(uv, u_squareSize - u_thickness);
      return outer - inner;
    }

    void main(){
      // Base pattern (no chroma/glow here—those are separate passes)
      float g = renderPattern(vUv, 0.0);
      // Make a neutral grayscale base; later passes colorize/shift/blur as needed
      gl_FragColor = vec4(vec3(g), 1.0);
    }
  `
};
const kaleidoPass = new ShaderPass(KaleidoShader);
composer.addPass(kaleidoPass);

// 2) Chroma blur pass (adds RGB offsets + 1D blur)
const ChromaBlurShader = {
  uniforms: {
    tDiffuse:     { value: null },
    u_time:       { value: 0 },
    u_resolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
    u_chromaOffset:{ value: params.chromaOffset },
    u_chromaBlur: { value: params.chromaBlur },
  },
  vertexShader: KaleidoShader.vertexShader,
  fragmentShader: /* glsl */`
    precision mediump float;
    varying vec2 vUv;
    uniform sampler2D tDiffuse;
    uniform vec2  u_resolution;
    uniform float u_chromaOffset, u_chromaBlur;

    void main(){
      float blur = u_chromaBlur * 0.01;
      vec2 texel = vec2(1.0 / u_resolution.x, 0.0);

      vec3 col = vec3(0.0);
      float total = 0.0;

      // 5-tap horizontal blur, with per-channel offsets
      for (int i=-2; i<=2; i++){
        float w = 1.0 - abs(float(i))*0.2;
        float off = float(i)*blur;

        float r = texture2D(tDiffuse, vUv + vec2(off + u_chromaOffset, 0.0)).r;
        float g = texture2D(tDiffuse, vUv + vec2(off, 0.0)).g;
        float b = texture2D(tDiffuse, vUv + vec2(off - u_chromaOffset, 0.0)).b;

        col += vec3(r,g,b) * w;
        total += w;
      }
      col /= total;

      gl_FragColor = vec4(col, 1.0);
    }
  `
};
const chromaPass = new ShaderPass(ChromaBlurShader);
composer.addPass(chromaPass);

// 3) Glow pass (radial neighborhood sample of current texture)
const GlowShader = {
  uniforms: {
    tDiffuse:     { value: null },
    u_resolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
    u_glowStrength:{ value: params.glowStrength },
    u_glowSteps:  { value: params.glowSteps },
  },
  vertexShader: KaleidoShader.vertexShader,
  fragmentShader: /* glsl */`
    precision mediump float;
    varying vec2 vUv;
    uniform sampler2D tDiffuse;
    uniform float u_glowStrength;
    uniform float u_glowSteps;

    #define MAX_GLOW_STEPS 32

    void main(){
      vec3 base = texture2D(tDiffuse, vUv).rgb;

      int steps = int(clamp(u_glowSteps, 1.0, float(MAX_GLOW_STEPS)));
      float radius = u_glowStrength * 0.01;

      float accum = 0.0;
      for (int i=0; i<MAX_GLOW_STEPS; i++){
        if (i >= steps) break;
        float ang = float(i) * 6.2831853 / float(steps);
        vec2  off = vec2(cos(ang), sin(ang)) * radius;
        accum += dot(texture2D(tDiffuse, vUv + off).rgb, vec3(0.299,0.587,0.114));
      }
      float glow = accum / float(steps);

      vec3 color = base + glow * u_glowStrength;
      gl_FragColor = vec4(color, 1.0);
    }
  `
};
const glowPass = new ShaderPass(GlowShader);
composer.addPass(glowPass);

// 4) Glitch (horizontal chunk shifts)
const GlitchShader = {
  uniforms: {
    tDiffuse:      { value: null },
    u_time:        { value: 0 },
    u_resolution:  { value: new THREE.Vector2(innerWidth, innerHeight) },
    u_glitchStrength:{ value: params.strength },
    u_chunkSize:   { value: params.chunkSize },
    u_glitchSpeed: { value: params.glitchSpeed },
    u_glitchChance:{ value: params.chance },
  },
  vertexShader: KaleidoShader.vertexShader,
  fragmentShader: /* glsl */`
    precision mediump float;
    varying vec2 vUv;
    uniform sampler2D tDiffuse;
    uniform vec2  u_resolution;
    uniform float u_time;
    uniform float u_glitchStrength;
    uniform float u_chunkSize;   // pixels
    uniform float u_glitchSpeed;
    uniform float u_glitchChance;

    float rand(float y){
      return fract(sin(y * 43758.5453 + u_time * u_glitchSpeed) * 12345.6789);
    }

    void main(){
      float normChunk = max(1.0, u_chunkSize) / u_resolution.y; // normalize by height
      float idx = floor(vUv.y / normChunk);
      float should = step(1.0 - u_glitchChance, rand(idx));
      float offset = (rand(idx+1.0) * 2.0 - 1.0) * u_glitchStrength * should;
      vec2 uv = vUv;
      uv.x += offset;
      gl_FragColor = texture2D(tDiffuse, uv);
    }
  `
};
const glitchPass = new ShaderPass(GlitchShader);
composer.addPass(glitchPass);

/* ===== GUI ===== */
const gui = new GUI({ title: 'Controls' });

function addControllers(folderName, keys) {
  const f = gui.addFolder(folderName);
  keys.forEach(k => {
    const d = paramDefs[k];
    const c = f.add(params, k, d.min, d.max, d.step).name(k);
    c.onChange(updateUniforms);
  });
  f.add({ randomize: () => { randomize(keys); updateUniforms(true); } }, 'randomize').name('Randomize');
  return f;
}
const fKaleido   = addControllers('Kaleidoscope', ['tileCount','squareSize','thickness','kaleidoSides','speed']);
const fDistort   = addControllers('Distortion',   ['distortionAmp','distortionFreq']);
const fChroma    = addControllers('Chromatic',    ['chromaOffset','chromaBlur']);
const fGlow      = addControllers('Glow',         ['glowStrength','glowSteps']);
const fSpiral    = addControllers('Spiral',       ['spiralStrength','spiralSpeed']);
const fGlitch    = addControllers('Glitch',       ['strength','chunkSize','glitchSpeed','chance']);

// Spiral mode toggle button with label
const SpiralModeAPI = {
  toggle: () => {
    params.spiralMode = (params.spiralMode === 1 ? 0 : 1);
    spiralModeCtrl.name(`Spiral Mode: ${params.spiralMode ? 'Compounding' : 'Oscillating'}`);
    updateUniforms(true);
  }
};
const spiralModeCtrl = fSpiral.add(SpiralModeAPI, 'toggle').name(`Spiral Mode: ${params.spiralMode ? 'Compounding' : 'Oscillating'}`);

// Presets & utility
const presetFolder = gui.addFolder('Preset Manager');
presetFolder.add({ Reset: resetDefaults }, 'Reset').name('Reset to Default');
presetFolder.add({ Export: exportPreset }, 'Export').name('Export to File');
presetFolder.add({ Import: importPreset }, 'Import').name('Import from File');

function resetDefaults(){
  for (const k in paramDefs) params[k] = paramDefs[k].default;
  spiralModeCtrl.name(`Spiral Mode: ${params.spiralMode ? 'Compounding' : 'Oscillating'}`);
  updateUniforms(true);
}
function exportPreset(){
  const clean = {};
  for (const k in paramDefs) clean[k] = params[k];
  const blob = new Blob([JSON.stringify(clean, null, 2)], { type:'application/json' });
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'kaleido-preset.json'; a.click();
  URL.revokeObjectURL(url);
}
function importPreset(){
  const input = document.createElement('input');
  input.type = 'file'; input.accept = '.json';
  input.onchange = (e) => {
    const file = e.target.files[0]; if (!file) return;
    const r = new FileReader();
    r.onload = () => {
      try{
        const json = JSON.parse(r.result);
        for (const k in paramDefs) if (k in json) params[k] = json[k];
        // Clamp spiralMode to 0/1 in case file had a float
        params.spiralMode = (params.spiralMode >= 0.5) ? 1 : 0;
        spiralModeCtrl.name(`Spiral Mode: ${params.spiralMode ? 'Compounding' : 'Oscillating'}`);
        updateUniforms(true);
      } catch (err) { console.error('Import failed:', err); }
    };
    r.readAsText(file);
  };
  input.click();
}

function randomize(keys){
  keys.forEach(k => {
    const d = paramDefs[k];
    params[k] = THREE.MathUtils.lerp(d.min, d.max, Math.random() * randomDamping);
    if (d.step >= 1) params[k] = Math.round(params[k]); // keep ints like sides/steps neat
  });
}

function updateUniforms(refreshGUI=false){
  // Kaleido uniforms
  kaleidoPass.uniforms.u_tileCount.value      = params.tileCount;
  kaleidoPass.uniforms.u_squareSize.value     = params.squareSize;
  kaleidoPass.uniforms.u_thickness.value      = params.thickness;
  kaleidoPass.uniforms.u_kaleidoSides.value   = params.kaleidoSides;
  kaleidoPass.uniforms.u_speed.value          = params.speed;
  kaleidoPass.uniforms.u_distortionAmp.value  = params.distortionAmp;
  kaleidoPass.uniforms.u_distortionFreq.value = params.distortionFreq;
  kaleidoPass.uniforms.u_spiralStrength.value = params.spiralStrength;
  kaleidoPass.uniforms.u_spiralSpeed.value    = params.spiralSpeed;
  kaleidoPass.uniforms.u_spiralMode.value     = params.spiralMode;

  // Chroma
  chromaPass.uniforms.u_chromaOffset.value    = params.chromaOffset;
  chromaPass.uniforms.u_chromaBlur.value      = params.chromaBlur;

  // Glow
  glowPass.uniforms.u_glowStrength.value      = params.glowStrength;
  glowPass.uniforms.u_glowSteps.value         = params.glowSteps;

  // Glitch
  glitchPass.uniforms.u_glitchStrength.value  = params.strength;
  glitchPass.uniforms.u_chunkSize.value       = params.chunkSize;
  glitchPass.uniforms.u_glitchSpeed.value     = params.glitchSpeed;
  glitchPass.uniforms.u_glitchChance.value    = params.chance;

  if (refreshGUI) gui.controllersRecursive?.().forEach(c => c.updateDisplay?.());
}

/* ===== Render loop & resize ===== */
const clock = new THREE.Clock();

function onResize(){
  renderer.setSize(innerWidth, innerHeight);
  composer.setSize(innerWidth, innerHeight);
  kaleidoPass.uniforms.u_resolution.value.set(innerWidth, innerHeight);
  chromaPass.uniforms.u_resolution.value.set(innerWidth, innerHeight);
  glowPass.uniforms.u_resolution.value.set(innerWidth, innerHeight);
  glitchPass.uniforms.u_resolution.value.set(innerWidth, innerHeight);
}
addEventListener('resize', onResize);

function tick(){
  const t = clock.getElapsedTime();
  kaleidoPass.uniforms.u_time.value = t;
  chromaPass.uniforms.u_time && (chromaPass.uniforms.u_time.value = t);
  glitchPass.uniforms.u_time.value = t;
  composer.render();
  requestAnimationFrame(tick);
}
onResize();
updateUniforms(true);
tick();

</script>
</body>
</html>
